==========================
==========================
CD
Release pipelines
So the agent is now the software, which is used to run the tasks that are part of the deployment.

This agent will actually go out and download the artifacts from your Azure built pipelines 
and then run all of the tasks that are part of the release pipelines.


--
Create Web App
Create build pipeline - publish build artifacts
#Artifacts in releated-publised-drop

Create release pipeline
 choose build pipeline
 stage  - choose azure subscripcion

--
enabled continuous deployment trigger
-
multiple stages

---
create storage account - blob
release pipeline - ARM tempalte deployment

So here you can see your web application in place.

So over here, not only are you deploying the web application with the help of an ARM template, you are
actually going ahead and first creating the resource itself before the deployment.

1 ARM template which is the main.json 
{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "applanName": {
            "type": "string",
            "minLength": 1,
         "defaultValue": "demoplan1000"
        },
        "applanSKU": {
            "type": "string",
            "allowedValues": [
                "Free",
                "Shared",
                "Basic",
                "Standard"
            ],
            "defaultValue": "Standard"
        },
        "applanWorkerSize": {
            "type": "string",
            "allowedValues": [
                "0",
                "1",
                "2"
            ],
            "defaultValue": "1"
        }
    },
    "resources": [
        {
            "name": "[variables('demoappName')]",
            "type": "Microsoft.Web/sites",
            "location": "[resourceGroup().location]",
            "apiVersion": "2015-08-01",
            "dependsOn": [
                "[concat('Microsoft.Web/serverfarms/', parameters('applanName'))]"
            ],
            "tags": {
                "[concat('hidden-related:', resourceGroup().id, '/providers/Microsoft.Web/serverfarms/', parameters('applanName'))]": "Resource",
                "displayName": "demoapp"
            },
            "properties": {
                "name": "[variables('demoappName')]",
                "serverFarmId": "[resourceId('Microsoft.Web/serverfarms/', parameters('applanName'))]"
            }
        },
        {
            "name": "[parameters('applanName')]",
            "type": "Microsoft.Web/serverfarms",
            "location": "[resourceGroup().location]",
            "apiVersion": "2014-06-01",
            "dependsOn": [],
            "tags": {
                "displayName": "applan"
            },
            "properties": {
                "name": "[parameters('applanName')]",
                "sku": "[parameters('applanSKU')]",
                "workerSize": "[parameters('applanWorkerSize')]",
                "numberOfWorkers": 1
            }
        }
    ],
    "variables": {
        "demoappName": "staging-app-4000"
    }
}

--
2 parameters.json 
{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "applanName": {
            "value": "stagingplan1000"
        },
        "applanSKU": {
            "value": "Basic"
        }     
    }
}


---
Approvals

edit pipeline, pre deployment conditions - enable pre-deployment approvals - timeout

---
Gates
enable - add azure policy ,  
query items - query, bug <> closed
              Permissions for Shared Queries - select user: read allow

deleay before evaluations
----

Azure Policies
ezample tag in storage account

---
Deployment group
create in azure devops - copy script to vm - page personal token

create release pipeline
  add deployment group job
    add task - IIS web app manage, deploy

-----
Deploying docker
vm - install docker engine
// Installing the pre-requisites for installing the docker engine

sudo apt update

sudo apt install apt-transport-https ca-certificates curl software-properties-common

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"

sudo apt update

// Installing the docker engine

sudo apt install docker-ce

// Pulling the nginx image from Docker Hub

sudo docker pull nginx

// Seeing the images on the local system

sudo docker images

// Running the nginx image as a container

sudo docker run --name sampleapp -p 80:80 -d nginx

---
build 
// This is for publishing your .Net Core application from command prompt

dotnet publish

#winSCP - copy files to vm

dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.1
WORKDIR /app
COPY  . .
ENV ASPNETCORE_URLS http://*:80
EXPOSE 80
ENTRYPOINT ["dotnet", "docker-app.dll"]

// This is for building your docker image

sudo docker build -t dotnetapp .

// This is for running your custom image as a container

sudo docker run -d -p 80:80 dotnetapp

-----
create container registry

install azure cli
// Install the Azure command line interface

curl -sL https://packages.microsoft.com/keys/microsoft.asc | \

    gpg --dearmor | \

    sudo tee /etc/apt/trusted.gpg.d/microsoft.asc.gpg > /dev/null



AZ_REPO=$(lsb_release -cs)

echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | \

    sudo tee /etc/apt/sources.list.d/azure-cli.list

sudo apt-get update

sudo apt-get install azure-cli

// Login into your Azure account via the Azure command line interface

sudo az login

// Login into your Azure container registry

sudo az acr login --name appregistry1000

// Tag your image

sudo docker tag dotnetapp appregistry1000.azurecr.io/dotnetapp

// Then push the image onto Azure container registry

sudo docker push appregistry1000.azurecr.io/dotnetapp

-----
azure container instances

container registry - access keys - enable admin user
create container instance
----
create Kubernetes Service

variables in azure cloud shell

	$AKS_RESOURCE_GROUP="newgrp1"
	$AKS_CLUSTER_NAME="cluster"
	$ACR_RESOURCE_GROUP="newgrp1"
	$ACR_NAME="appregistry1000"

	// Get the client id of the service principal attached to Azure Kubernetes
	$CLIENT_ID=$(az aks show --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --query "servicePrincipalProfile.clientId" --output tsv)

	// Get the id of the Azure Container registry resource
	$ACR_ID=$(az acr show --name $ACR_NAME --resource-group $ACR_RESOURCE_GROUP --query "id" --output tsv)

	// Next you can assign the role
	az role assignment create --assignee $CLIENT_ID --role acrpull --scope $ACR_ID

workloads - add(yaml-deployment)

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-image
        image: appregistry1000.azurecr.io/dotnetapp
        ports:
        - containerPort: 80

services ingress - add(yaml-service)
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: my-app


---
	1 use dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build-env
WORKDIR /app
 
# Copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore
 
# Copy everything else and build
COPY . ./
RUN dotnet publish -c Release -o out
 
# Build runtime image
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
WORKDIR /app
COPY --from=build-env /app/out .
ENTRYPOINT ["dotnet", "docker-app.dll"]


	2 create pipeline - docker(build and push an imagen to Azure Container Registry)

use the task wizard to add the Docker task , because this will create the service connection to the Azure Container registry
# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
resources:
- repo: self
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'dbe0a89e-bfa1-45ed-bc4a-4e587ae8f0c2'
  imageRepository: 'dotnetapp'
  containerRegistry: 'appregistry60001.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/dockerweb/Dockerfile'  
  
  # Agent VM image name
  vmImageName: 'ubuntu-latest'
 
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          latest


---
Azure pipeline kubernetes
service connection kubernetes

# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
resources:
- repo: self
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'dbe0a89e-bfa1-45ed-bc4a-4e587ae8f0c2'
  imageRepository: 'dotnetapp'
  containerRegistry: 'appregistry60001.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/dockerweb/Dockerfile'  
  
  # Agent VM image name
  vmImageName: 'ubuntu-latest'
 
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          latest
    - task: CopyFiles@2
      inputs:
        SourceFolder: 'dockerweb/manifests'
        Contents: |
          app.yml
          service.yml
        TargetFolder: '$(Build.ArtifactStagingDirectory)'
 
    - task: KubernetesManifest@0
      inputs:
        action: 'deploy'
        manifests: |
           $(Build.ArtifactStagingDirectory)/app.yml
           $(Build.ArtifactStagingDirectory)/service.yml
        kubernetesServiceConnection: 'cluster-connection'
        containers: |
          appregistry60001.azurecr.io/dotnetapp:latest

--------------
pipeline
azure container registry 
- azure web app

create resource group
create web app

task - Azure Web App for Containers

--------
pipeline release-kubernetes

task: Deploy to Kubernetes
# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
resources:
- repo: self
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'dbe0a89e-bfa1-45ed-bc4a-4e587ae8f0c2'
  imageRepository: 'dotnetapp'
  containerRegistry: 'appregistry60001.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/dockerweb/Dockerfile'  
  
  # Agent VM image name
  vmImageName: 'ubuntu-latest'
 
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          latest
        
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Pipeline.Workspace)'
        artifact: 'dotnetapp'
        publishLocation: 'pipeline'


====================
Helm
This is a package management solution for applications that neeed
to be deployed onto Kubernetes clusters

// First ensure you have an Azure Kubernetes clusters in place

// Set the context to your Kubernetes cluster
az aks get-credentials --resource-group newgrp1 --name cluster1000

// Ensure the helm client can fetch the pre-configured helm charts
helm repo add stable https://kubernetes-charts.storage.googleapis.com/

// To see the pre-created charts or packages
helm search repo stable

// Install the mysql chart
helm install app-sql stable/mysql

You can use the following app.yml and service.yml files as reference for creating the helm chart
app.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-image
        image: nginx
        ports:
        - containerPort: 80

service.yml file
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: my-app

----
System defined variables
----
Container Job
# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
container: mcr.microsoft.com/dotnet/core/sdk:3.1
   
steps:
- task: DotNetCoreCLI@2
  displayName: dotnet restore
  inputs:
    command: restore
    projects: '**/*.csproj'
 
- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    command: build
    projects: '**/*.csproj'
    arguments: '--configuration release'



---
Container job - Publish to Azure Web app
pipeline build use container

# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
container: mcr.microsoft.com/dotnet/core/sdk:3.1
   
steps:
- task: DotNetCoreCLI@2
  displayName: dotnet restore
  inputs:
    command: restore
    projects: '**/*.csproj'
 
- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    command: build
    projects: '**/*.csproj'
    arguments: '--configuration release'
 
- task: DotNetCoreCLI@2
  displayName: Publish
  inputs:
    command: publish
    projects: '**/*.csproj'
    zipAfterPublish: true
    arguments: '--configuration release'
 
- task: CopyFiles@2
  inputs:
    SourceFolder: '$(Build.SourcesDirectory)'
    Contents: '**'
    TargetFolder: '$(Build.ArtifactStagingDirectory)'
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'
    publishLocation: 'Container'


pipeline release: use azure app service deploy
---------
ACR Task
Dockerfile:
FROM mcr.microsoft.com/donet/core/sdk:3.1
WORKDIR /app
COPY . .
ENV ASPNETCORE_URLS http://*:80
EXPOSE 80
ENTRYPOINT ["donet", "docker-app.dll"]

sudo az acr build --image appnew:latest --registry appregistry1000 --file Dockerfile .

---------
Copy agent into vmlinux - use WinSCCP
 install agent in vmlinux

pipeline with self-agent
use demands:
pool:
   name: 'Default'
   demands:
   - Agent.OS -equals Linux

yaml
# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
pool:
  name: 'Default'
  demands:
  - Agent.OS -equals Linux
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: '244da2f8-0698-4c29-b89a-da0ebdd9dc2e'
  imageRepository: 'newrepo'
  containerRegistry: 'demoregistry7000.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/newapp90000/Dockerfile'
  tag: 'latest'
  
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    
      
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)

----
Azure Web App - Azure Sql Database
Create database
	server

Create table with sql server:

CREATE TABLE Products (
    Id int NOT NULL IDENTITY,
    Name varchar(255) NOT NULL,
    price real,
    PRIMARY KEY (Id)
);
 
insert into Products(Name,price) values('ProductA',40.99);
 
insert into Products(Name,price) values('ProductB',50.99);
 
insert into Products(Name,price) values('ProductC',60.99);
 
drop table Products;

--
appsettigns in visual studio project - go to azure and copy connection string into appsettings.json

web app - azure
	configuration -connection string

--
create pipeline build - publish artifacts
create release pipeline 
task- Azure SQL Database deployment, 
				Password[$(sqlpassword)],
				Deploy type: Inline SQL Script
		-Variables
			add Name sqlpassword, Value - pass

task - Azure App Service Deploy
task - Azure App Service Settings
	Connection Strings
	[
		{
		"name": "SqlCredentials",
		"value": "$(SQL_ConnectionString)",
		"type": "SQLAzure",
		"slotSetting": false
		}
	]

		-Varibles 
			add SQL_ConnectionString

remove connection string in appsettings.json file


--------
OWASP - release pipeline

release pipeline - azure cli(rename)
task: azure cli(create resource group) - inline script: az group create -l centralus -n owasp_grp

task :azure cli(create the storage account) - inline script:
az storage account create -g owasp_grp -n owaspstore1000 -l centralus --sku Standard_LRS
az storage share create -n security --account-name owaspstore1000

task :azure cli(create OWASP Container) get access key for storage account
script in powershell
az storage account keys list -g owasp_grp --account-name owaspstore1000 --query "[0].value" --output tsv > temp.txt
	$content = Get-Content temp.txt -First 1
	$key = '"{0}"' -f $content
 
	echo "https://stagingapp1000.azurewebsites.net"> url.txt
	$url = Get-Content url.txt -First 1
	$completeurl = '"{0}"' -f $url
 
	$ZAP_COMMAND="/zap/zap-baseline.py -t $completeurl -x OWASP-ZAP-Report.xml"
 
	az container create -g owasp_grp -n owasp --image owasp/zap2docker-stable --ip-address public --ports 8080 --azure-file-volume-account-name owaspstore1000 --azure-file-volume-account-key $key --azure-file-volume-share-name security --azure-file-volume-mount-path /zap/wrk/ --command-line $ZAP_COMMAND

task :azure cli(Download the report)
	az storage account keys list -g owasp_grp --account-name owaspstore1000 --query "[0].value" --output tsv > temp.txt
	$content = Get-Content temp.txt -First 1
	$key = '"{0}"' -f $content
 
	az storage file download --account-name owaspstore1000 --account-key $key -s security -p OWASP-ZAP-Report.xml --dest %SYSTEM_DEFAULTWORKINGDIRECTORY%\OWASP-ZAP-Report.xml

task: Powershell (Convert report format)
$XslPath = "$($Env:SYSTEM_DEFAULTWORKINGDIRECTORY)\_newapp1000\demoweb20000\OWASPToNUnit3.xslt"
$XmlInputPath = "$($Env:SYSTEM_DEFAULTWORKINGDIRECTORY)\OWASP-ZAP-Report.xml"
$XmlOutputPath = "$($Env:SYSTEM_DEFAULTWORKINGDIRECTORY)\Converted-OWASP-ZAP-Report.xml"
$XslTransform = New-Object System.Xml.Xsl.XslCompiledTransform
$XslTransform.Load($XslPath)
$XslTransform.Transform($XmlInputPath, $XmlOutputPath)


task:Publish Test Results
NUnit

view in storage account report
---
Azure Key Vault
Create key vault
   Create secret

pipeline release
task Azure Key Vault
		- screts filter - vmpassword

task azure cli 
  -Shell, inline script 

service connection

add access policy
-------------------
azure devops - pipelines - library
	 -add variable group

# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
variables:
- group: demogroup
stages:
- stage: demostage
  jobs:
  - job: Test
    steps:
    - script: echo $(secret)


-----
Lab - Azure Pipelines - Variable Groups - Azure Key Vault - Resources
 https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
variables:
- group: demogroup
stages:
- stage: demostage
  jobs:
  - job: Test
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: 'Test Environment (20c6eec9-2d80-4700-b0f6-4fde579a8783)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: 'az vm create --resource-group newgrp1 --name demovm3 --image win2016datacenter --admin-username demousr --admin-password $(newpassword)'


---
in release pipeline
you can delete azure key vault, 
  and the option variable, use de last group variable

----------------
----------------
Selenium

validate en ui web page, title

build pipeline - publish artifacts
# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
 
trigger:
- master
 
pool:
  vmImage: 'windows-latest'
 
steps:
- task: DotNetCoreCLI@2
  displayName: Restore
  inputs:
    command: restore
    projects: '**/seleniumtest.csproj'
 
- task: DotNetCoreCLI@2
  displayName: Publish
  inputs:
    command: publish
    publishWebProjects: false
    projects: '**/seleniumtest.csproj'
    arguments: '--configuration Release -o $(build.artifactstagingdirectory)'
    zipAfterPublish: false
    modifyOutputPath: false
 
- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'


create relase pipeline
 task: Visual Studio Test Platform Installer
 task: vsTest - testAssemblies
       search $(System.DefaultWorkingDirectory)\_seleniumtest\drop


----
blue green deployment strategy

canary deployment- 
 Azure traffic manager, Weighted Routing method
 20% traffic - 80% traffic

Rolling deployment
set of vm, actualizar poco a poco un set de vm

features flags

available for users, and enable o disable features depending the context in app

----
deployment slots
create slot
go to swap
change slot to deploy different version

create build pipeline - publish artifacts
select artifact create release pipeline
stage pre-production
add task: azure cli
	ps-inline: script az webapp deployment slot create --name slotapp1000 --reource-group newgrp1 --slot staging
add task: azure app service deploy

add post deployment conditions - approval
stage production
add task: Azure App Service Manager(swap slots)
--------
Azure Traffic Manager
DNS Level
ip public - vm define dns
go to[internal endpoints - azure web app, azure vm, azure load balancer, 
      External endpoints - On-premises web server, static web site]
--
Priority Routing Method
So let's say that you have your application running has and as your webapp in the East US region, so
let's say you set up as your traffic manager and all of the users will be directed on to the application

Weighted Routing Method (weightage - 50% - 50%)
Normally, the routing method is used in deployments, which is known as the blue green deployment.

Performace Routing Method
azure web application
So, again, over here, you might be having multiple applications, one in the East Coast region and
the other one in the best U.S. region.

So if a user is located closer to the East Coast region, that request will go onto that as your Web
application.

And if a user is located closer to the best U.S. region, they could be, you know, directed onto the
other as your Web application.

-------
Azure Traffic Manager

Azure Web App in different region
publish different version app with vs

Creare Traffic Manager profile
	-Routing method: priority

Add endpoint
-----
build pipeline
release pipeline
stage pre-produccion
   azure app service deploy

    azure cli
    $webid=az resource list --name 'stagingweb1000' --query [].id --output tsv
    $id = '"{0}"' -f $webid
    az network traffic-manager endpoint create -g newgrp1 --profile-name app-profile1000 -n endpoint-version2 --type azureEndpoints --target-resource-id $id --endpoint-status enabled --priority 2

stage producction
   azure app service manage (swap slots)
----
terraform

build pipeline - Existing Azure Pipeline yaml file
    # Starter pipeline
    # Start with a minimal pipeline that you can customize to build and deploy your code.
    # Add steps that build, run tests, deploy, and more:
    # https://aka.ms/yaml
    trigger:
    - master
     
    pool:
      vmImage: 'ubuntu-latest'
     
    steps:
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Pipeline.Workspace)'
        artifact: 'drop'
        publishLocation: 'pipeline'


   publish

stage terraform
release pipeline 
   task: azure cli - create storage account
    
    az storage account create -g newgrp1 -n terraform10001 -l centralus --sku Standard_LRS
    az storage container create --name terraform --acount-name terraform10001 
    az storage account keys list -g newgrp1 --account-name terraform10001 --query "[0].value" --output tsv > temp.txt
    $content = Get-Content temp.txt -First 1
    $key = '"{0}"' -f $content

   task: terraform tool installer
   task: terraform (init)   key: name statefile
   task: terraform (plan)
   task: terraform (apply)



========================================
========================================
Site reability 

azure load balancer, azure virtual machines scale sets, azure traffic manager

create 2 vm and load balancer
ip configuration  -edit public ip adress - disassociate
                   Assigment static

create ip address

create load balancer
      choose ip - select ip

 backend pools - add
             add vm

 Health pools

 Load balancing rule
-----
Machine Scale Sets

Create machine scale set
 