==========================
==========================
CD
Release pipelines
So the agent is now the software, which is used to run the tasks that are part of the deployment.

This agent will actually go out and download the artifacts from your Azure built pipelines 
and then run all of the tasks that are part of the release pipelines.


--
Create Web App
Create build pipeline - publish build artifacts
#Artifacts in releated-publised-drop

Create release pipeline
 choose build pipeline
 stage  - choose azure subscripcion

--
enabled continuous deployment trigger
-
multiple stages

---
create storage account - blob
release pipeline - ARM tempalte deployment

So here you can see your web application in place.

So over here, not only are you deploying the web application with the help of an ARM template, you are
actually going ahead and first creating the resource itself before the deployment.

1 ARM template which is the main.json 
{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "applanName": {
            "type": "string",
            "minLength": 1,
         "defaultValue": "demoplan1000"
        },
        "applanSKU": {
            "type": "string",
            "allowedValues": [
                "Free",
                "Shared",
                "Basic",
                "Standard"
            ],
            "defaultValue": "Standard"
        },
        "applanWorkerSize": {
            "type": "string",
            "allowedValues": [
                "0",
                "1",
                "2"
            ],
            "defaultValue": "1"
        }
    },
    "resources": [
        {
            "name": "[variables('demoappName')]",
            "type": "Microsoft.Web/sites",
            "location": "[resourceGroup().location]",
            "apiVersion": "2015-08-01",
            "dependsOn": [
                "[concat('Microsoft.Web/serverfarms/', parameters('applanName'))]"
            ],
            "tags": {
                "[concat('hidden-related:', resourceGroup().id, '/providers/Microsoft.Web/serverfarms/', parameters('applanName'))]": "Resource",
                "displayName": "demoapp"
            },
            "properties": {
                "name": "[variables('demoappName')]",
                "serverFarmId": "[resourceId('Microsoft.Web/serverfarms/', parameters('applanName'))]"
            }
        },
        {
            "name": "[parameters('applanName')]",
            "type": "Microsoft.Web/serverfarms",
            "location": "[resourceGroup().location]",
            "apiVersion": "2014-06-01",
            "dependsOn": [],
            "tags": {
                "displayName": "applan"
            },
            "properties": {
                "name": "[parameters('applanName')]",
                "sku": "[parameters('applanSKU')]",
                "workerSize": "[parameters('applanWorkerSize')]",
                "numberOfWorkers": 1
            }
        }
    ],
    "variables": {
        "demoappName": "staging-app-4000"
    }
}

--
2 parameters.json 
{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "applanName": {
            "value": "stagingplan1000"
        },
        "applanSKU": {
            "value": "Basic"
        }     
    }
}


---
Approvals

edit pipeline, pre deployment conditions - enable pre-deployment approvals - timeout

---
Gates
enable - add azure policy ,  
query items - query, bug <> closed
              Permissions for Shared Queries - select user: read allow

deleay before evaluations
----

Azure Policies
ezample tag in storage account

---
Deployment group
create in azure devops - copy script to vm - page personal token

create release pipeline
  add deployment group job
    add task - IIS web app manage, deploy

-----
Deploying docker
vm - install docker engine
// Installing the pre-requisites for installing the docker engine

sudo apt update

sudo apt install apt-transport-https ca-certificates curl software-properties-common

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"

sudo apt update

// Installing the docker engine

sudo apt install docker-ce

// Pulling the nginx image from Docker Hub

sudo docker pull nginx

// Seeing the images on the local system

sudo docker images

// Running the nginx image as a container

sudo docker run --name sampleapp -p 80:80 -d nginx

---
build 
// This is for publishing your .Net Core application from command prompt

dotnet publish

#winSCP - copy files to vm

dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.1
WORKDIR /app
COPY  . .
ENV ASPNETCORE_URLS http://*:80
EXPOSE 80
ENTRYPOINT ["dotnet", "docker-app.dll"]

// This is for building your docker image

sudo docker build -t dotnetapp .

// This is for running your custom image as a container

sudo docker run -d -p 80:80 dotnetapp

-----
create container registry

install azure cli
// Install the Azure command line interface

curl -sL https://packages.microsoft.com/keys/microsoft.asc | \

    gpg --dearmor | \

    sudo tee /etc/apt/trusted.gpg.d/microsoft.asc.gpg > /dev/null



AZ_REPO=$(lsb_release -cs)

echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | \

    sudo tee /etc/apt/sources.list.d/azure-cli.list

sudo apt-get update

sudo apt-get install azure-cli

// Login into your Azure account via the Azure command line interface

sudo az login

// Login into your Azure container registry

sudo az acr login --name appregistry1000

// Tag your image

sudo docker tag dotnetapp appregistry1000.azurecr.io/dotnetapp

// Then push the image onto Azure container registry

sudo docker push appregistry1000.azurecr.io/dotnetapp

-----
azure container instances

container registry - access keys - enable admin user
create container instance
----
create Kubernetes Service

variables in azure cloud shell

	$AKS_RESOURCE_GROUP="newgrp1"
	$AKS_CLUSTER_NAME="cluster"
	$ACR_RESOURCE_GROUP="newgrp1"
	$ACR_NAME="appregistry1000"

	// Get the client id of the service principal attached to Azure Kubernetes
	$CLIENT_ID=$(az aks show --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --query "servicePrincipalProfile.clientId" --output tsv)

	// Get the id of the Azure Container registry resource
	$ACR_ID=$(az acr show --name $ACR_NAME --resource-group $ACR_RESOURCE_GROUP --query "id" --output tsv)

	// Next you can assign the role
	az role assignment create --assignee $CLIENT_ID --role acrpull --scope $ACR_ID

workloads - add(yaml-deployment)

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-image
        image: appregistry1000.azurecr.io/dotnetapp
        ports:
        - containerPort: 80

services ingress - add(yaml-service)
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: my-app


---
	1 use dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build-env
WORKDIR /app
 
# Copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore
 
# Copy everything else and build
COPY . ./
RUN dotnet publish -c Release -o out
 
# Build runtime image
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
WORKDIR /app
COPY --from=build-env /app/out .
ENTRYPOINT ["dotnet", "docker-app.dll"]


	2 create pipeline - docker(build and push an imagen to Azure Container Registry)

use the task wizard to add the Docker task , because this will create the service connection to the Azure Container registry
# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
resources:
- repo: self
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'dbe0a89e-bfa1-45ed-bc4a-4e587ae8f0c2'
  imageRepository: 'dotnetapp'
  containerRegistry: 'appregistry60001.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/dockerweb/Dockerfile'  
  
  # Agent VM image name
  vmImageName: 'ubuntu-latest'
 
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          latest


---
Azure pipeline kubernetes
service connection kubernetes

# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
resources:
- repo: self
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'dbe0a89e-bfa1-45ed-bc4a-4e587ae8f0c2'
  imageRepository: 'dotnetapp'
  containerRegistry: 'appregistry60001.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/dockerweb/Dockerfile'  
  
  # Agent VM image name
  vmImageName: 'ubuntu-latest'
 
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          latest
    - task: CopyFiles@2
      inputs:
        SourceFolder: 'dockerweb/manifests'
        Contents: |
          app.yml
          service.yml
        TargetFolder: '$(Build.ArtifactStagingDirectory)'
 
    - task: KubernetesManifest@0
      inputs:
        action: 'deploy'
        manifests: |
           $(Build.ArtifactStagingDirectory)/app.yml
           $(Build.ArtifactStagingDirectory)/service.yml
        kubernetesServiceConnection: 'cluster-connection'
        containers: |
          appregistry60001.azurecr.io/dotnetapp:latest

--------------
pipeline
azure container registry 
- azure web app

create resource group
create web app

task - Azure Web App for Containers

--------
pipeline release-kubernetes

task: Deploy to Kubernetes
# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
resources:
- repo: self
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'dbe0a89e-bfa1-45ed-bc4a-4e587ae8f0c2'
  imageRepository: 'dotnetapp'
  containerRegistry: 'appregistry60001.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/dockerweb/Dockerfile'  
  
  # Agent VM image name
  vmImageName: 'ubuntu-latest'
 
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          latest
        
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Pipeline.Workspace)'
        artifact: 'dotnetapp'
        publishLocation: 'pipeline'


====================
Helm
This is a package management solution for applications that neeed
to be deployed onto Kubernetes clusters

// First ensure you have an Azure Kubernetes clusters in place

// Set the context to your Kubernetes cluster
az aks get-credentials --resource-group newgrp1 --name cluster1000

// Ensure the helm client can fetch the pre-configured helm charts
helm repo add stable https://kubernetes-charts.storage.googleapis.com/

// To see the pre-created charts or packages
helm search repo stable

// Install the mysql chart
helm install app-sql stable/mysql

You can use the following app.yml and service.yml files as reference for creating the helm chart
app.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-image
        image: nginx
        ports:
        - containerPort: 80

service.yml file
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: my-app

----
System defined variables
----
Container Job
# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
container: mcr.microsoft.com/dotnet/core/sdk:3.1
   
steps:
- task: DotNetCoreCLI@2
  displayName: dotnet restore
  inputs:
    command: restore
    projects: '**/*.csproj'
 
- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    command: build
    projects: '**/*.csproj'
    arguments: '--configuration release'



---
Container job - Publish to Azure Web app
pipeline build use container

# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
container: mcr.microsoft.com/dotnet/core/sdk:3.1
   
steps:
- task: DotNetCoreCLI@2
  displayName: dotnet restore
  inputs:
    command: restore
    projects: '**/*.csproj'
 
- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    command: build
    projects: '**/*.csproj'
    arguments: '--configuration release'
 
- task: DotNetCoreCLI@2
  displayName: Publish
  inputs:
    command: publish
    projects: '**/*.csproj'
    zipAfterPublish: true
    arguments: '--configuration release'
 
- task: CopyFiles@2
  inputs:
    SourceFolder: '$(Build.SourcesDirectory)'
    Contents: '**'
    TargetFolder: '$(Build.ArtifactStagingDirectory)'
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'
    publishLocation: 'Container'


pipeline release: use azure app service deploy
---------
ACR Task
Dockerfile:
FROM mcr.microsoft.com/donet/core/sdk:3.1
WORKDIR /app
COPY . .
ENV ASPNETCORE_URLS http://*:80
EXPOSE 80
ENTRYPOINT ["donet", "docker-app.dll"]

sudo az acr build --image appnew:latest --registry appregistry1000 --file Dockerfile .

---------
Copy agent into vmlinux - use WinSCCP
 install agent in vmlinux

pipeline with self-agent
use demands:
pool:
   name: 'Default'
   demands:
   - Agent.OS -equals Linux

yaml
# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
pool:
  name: 'Default'
  demands:
  - Agent.OS -equals Linux
 
variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: '244da2f8-0698-4c29-b89a-da0ebdd9dc2e'
  imageRepository: 'newrepo'
  containerRegistry: 'demoregistry7000.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/newapp90000/Dockerfile'
  tag: 'latest'
  
stages:
- stage: Build
  displayName: Build and push stage
  jobs:  
  - job: Build
    displayName: Build
    
      
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)

----
Azure Web App - Azure Sql Database
Create database
	server

Create table with sql server:

CREATE TABLE Products (
    Id int NOT NULL IDENTITY,
    Name varchar(255) NOT NULL,
    price real,
    PRIMARY KEY (Id)
);
 
insert into Products(Name,price) values('ProductA',40.99);
 
insert into Products(Name,price) values('ProductB',50.99);
 
insert into Products(Name,price) values('ProductC',60.99);
 
drop table Products;

--
appsettigns in visual studio project - go to azure and copy connection string into appsettings.json

web app - azure
	configuration -connection string

--
create pipeline build - publish artifacts
create release pipeline 
task- Azure SQL Database deployment, 
				Password[$(sqlpassword)],
				Deploy type: Inline SQL Script
		-Variables
			add Name sqlpassword, Value - pass

task - Azure App Service Deploy
task - Azure App Service Settings
	Connection Strings
	[
		{
		"name": "SqlCredentials",
		"value": "$(SQL_ConnectionString)",
		"type": "SQLAzure",
		"slotSetting": false
		}
	]

		-Varibles 
			add SQL_ConnectionString

remove connection string in appsettings.json file


--------
OWASP - release pipeline

release pipeline - azure cli(rename)
task: azure cli(create resource group) - inline script: az group create -l centralus -n owasp_grp

task :azure cli(create the storage account) - inline script:
az storage account create -g owasp_grp -n owaspstore1000 -l centralus --sku Standard_LRS
az storage share create -n security --account-name owaspstore1000

task :azure cli(create OWASP Container) get access key for storage account
script in powershell
az storage account keys list -g owasp_grp --account-name owaspstore1000 --query "[0].value" --output tsv > temp.txt
	$content = Get-Content temp.txt -First 1
	$key = '"{0}"' -f $content
 
	echo "https://stagingapp1000.azurewebsites.net"> url.txt
	$url = Get-Content url.txt -First 1
	$completeurl = '"{0}"' -f $url
 
	$ZAP_COMMAND="/zap/zap-baseline.py -t $completeurl -x OWASP-ZAP-Report.xml"
 
	az container create -g owasp_grp -n owasp --image owasp/zap2docker-stable --ip-address public --ports 8080 --azure-file-volume-account-name owaspstore1000 --azure-file-volume-account-key $key --azure-file-volume-share-name security --azure-file-volume-mount-path /zap/wrk/ --command-line $ZAP_COMMAND

task :azure cli(Download the report)
	az storage account keys list -g owasp_grp --account-name owaspstore1000 --query "[0].value" --output tsv > temp.txt
	$content = Get-Content temp.txt -First 1
	$key = '"{0}"' -f $content
 
	az storage file download --account-name owaspstore1000 --account-key $key -s security -p OWASP-ZAP-Report.xml --dest %SYSTEM_DEFAULTWORKINGDIRECTORY%\OWASP-ZAP-Report.xml

task: Powershell (Convert report format)
$XslPath = "$($Env:SYSTEM_DEFAULTWORKINGDIRECTORY)\_newapp1000\demoweb20000\OWASPToNUnit3.xslt"
$XmlInputPath = "$($Env:SYSTEM_DEFAULTWORKINGDIRECTORY)\OWASP-ZAP-Report.xml"
$XmlOutputPath = "$($Env:SYSTEM_DEFAULTWORKINGDIRECTORY)\Converted-OWASP-ZAP-Report.xml"
$XslTransform = New-Object System.Xml.Xsl.XslCompiledTransform
$XslTransform.Load($XslPath)
$XslTransform.Transform($XmlInputPath, $XmlOutputPath)


task:Publish Test Results
NUnit

view in storage account report
---
Azure Key Vault
Create key vault
   Create secret

pipeline release
task Azure Key Vault
		- screts filter - vmpassword

task azure cli 
  -Shell, inline script 

service connection

add access policy
-------------------
azure devops - pipelines - library
	 -add variable group

# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
variables:
- group: demogroup
stages:
- stage: demostage
  jobs:
  - job: Test
    steps:
    - script: echo $(secret)


-----
Lab - Azure Pipelines - Variable Groups - Azure Key Vault - Resources
 https://docs.microsoft.com/azure/devops/pipelines/languages/docker
 
trigger:
- master
 
pool:
  vmImage: 'ubuntu-latest'
 
variables:
- group: demogroup
stages:
- stage: demostage
  jobs:
  - job: Test
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: 'Test Environment (20c6eec9-2d80-4700-b0f6-4fde579a8783)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: 'az vm create --resource-group newgrp1 --name demovm3 --image win2016datacenter --admin-username demousr --admin-password $(newpassword)'


---
in release pipeline
you can delete azure key vault, 
  and the option variable, use de last group variable

----------------
----------------
Selenium

validate en ui web page, title

build pipeline - publish artifacts
# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
 
trigger:
- master
 
pool:
  vmImage: 'windows-latest'
 
steps:
- task: DotNetCoreCLI@2
  displayName: Restore
  inputs:
    command: restore
    projects: '**/seleniumtest.csproj'
 
- task: DotNetCoreCLI@2
  displayName: Publish
  inputs:
    command: publish
    publishWebProjects: false
    projects: '**/seleniumtest.csproj'
    arguments: '--configuration Release -o $(build.artifactstagingdirectory)'
    zipAfterPublish: false
    modifyOutputPath: false
 
- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'


create relase pipeline
 task: Visual Studio Test Platform Installer
 task: vsTest - testAssemblies
       search $(System.DefaultWorkingDirectory)\_seleniumtest\drop


----
blue green deployment strategy

canary deployment- 
 Azure traffic manager, Weighted Routing method
 20% traffic - 80% traffic

Rolling deployment
set of vm, actualizar poco a poco un set de vm

features flags

available for users, and enable o disable features depending the context in app

----
deployment slots
create slot
go to swap
change slot to deploy different version

create build pipeline - publish artifacts
select artifact create release pipeline
stage pre-production
add task: azure cli
	ps-inline: script az webapp deployment slot create --name slotapp1000 --reource-group newgrp1 --slot staging
add task: azure app service deploy

add post deployment conditions - approval
stage production
add task: Azure App Service Manager(swap slots)
--------
Azure Traffic Manager
DNS Level
ip public - vm define dns
go to[internal endpoints - azure web app, azure vm, azure load balancer, 
      External endpoints - On-premises web server, static web site]
--
Priority Routing Method
So let's say that you have your application running has and as your webapp in the East US region, so
let's say you set up as your traffic manager and all of the users will be directed on to the application

Weighted Routing Method (weightage - 50% - 50%)
Normally, the routing method is used in deployments, which is known as the blue green deployment.

Performace Routing Method
azure web application
So, again, over here, you might be having multiple applications, one in the East Coast region and
the other one in the best U.S. region.

So if a user is located closer to the East Coast region, that request will go onto that as your Web
application.

And if a user is located closer to the best U.S. region, they could be, you know, directed onto the
other as your Web application.

-------
Azure Traffic Manager

Azure Web App in different region
publish different version app with vs

Creare Traffic Manager profile
	-Routing method: priority

Add endpoint
-----
build pipeline
release pipeline
stage pre-produccion
   azure app service deploy

    azure cli
    $webid=az resource list --name 'stagingweb1000' --query [].id --output tsv
    $id = '"{0}"' -f $webid
    az network traffic-manager endpoint create -g newgrp1 --profile-name app-profile1000 -n endpoint-version2 --type azureEndpoints --target-resource-id $id --endpoint-status enabled --priority 2

stage producction
   azure app service manage (swap slots)
----
terraform

build pipeline - Existing Azure Pipeline yaml file
    # Starter pipeline
    # Start with a minimal pipeline that you can customize to build and deploy your code.
    # Add steps that build, run tests, deploy, and more:
    # https://aka.ms/yaml
    trigger:
    - master
     
    pool:
      vmImage: 'ubuntu-latest'
     
    steps:
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Pipeline.Workspace)'
        artifact: 'drop'
        publishLocation: 'pipeline'


   publish

stage terraform
release pipeline 
   task: azure cli - create storage account
    
    az storage account create -g newgrp1 -n terraform10001 -l centralus --sku Standard_LRS
    az storage container create --name terraform --acount-name terraform10001 
    az storage account keys list -g newgrp1 --account-name terraform10001 --query "[0].value" --output tsv > temp.txt
    $content = Get-Content temp.txt -First 1
    $key = '"{0}"' -f $content

   task: terraform tool installer
   task: terraform (init)   key: name statefile
   task: terraform (plan)
   task: terraform (apply)



========================================
========================================
Site reability 

azure load balancer, azure virtual machines scale sets, azure traffic manager

create 2 vm and load balancer
ip configuration  -edit public ip adress - disassociate
                   Assigment static

create ip address

create load balancer
      choose ip - select ip

 backend pools - add
             add vm

 Health pools

 Load balancing rule
-----
Machine Scale Sets

The virtual machine scale set will automatically scale the number of virtual machines 
based on demand
You define the configuration of the virtual machine that would be part of the scale set
You then define the scaling conditions

Create machine scale set
  edit network interface - select inbound ports . http80,rdp3389

  Load Balancing -yes

  monitor application health - enabled

  automatic repairs - on - grace period-30min (is not working vm, snpin up that a new vm)



storage account, container blob - upload script
script.ps1
Add-WindowsFeature Web-Server
Set-Content -Path "C:\inetpub\wwwroot\app.html" -Value "Computer Name $($env:computername) !"



vm scale set - upgrade: apply that custom script extension

azure cloud shell

$config = @{
  "fileUris" = (,"https://artifactstore4000.blob.core.windows.net/script/script.ps1");
  "commandToExecute" = "powershell -ExecutionPolicy Unrestricted -File script.ps1"
}

$set = Get-AzVmss -ResourceGroupName "newgrp1" -VMScaleSetName "demoset"

$set = Add-AzVmssExtension -VirtualMachineScaleSet $set -Name "customScript" -Publisher "Microsoft.Compute" -Type "CustomScriptExtension" -TypeHandlerVersion 1.9 -Setting $config

Update-AzVmss -ResourceGroupName "newgrp1" -Name "demoset" -VirtualMachineScaleSet $set
 
---
load balancer - Inbound NAT rules - view ip to connect
uninstall iis, wait 30min and see repair vm

--
storage acount add queue
all resource - virtual machine scale set  -scaling
     custom autoscale - instance limits : maximum 3
     add rule
     Check Enable metric divide by instance count: looking at the average CPU utilization that's across all of the virtual machines, which are part of the skill set.
     metric source Storage queue, select resource



-----------------
Azure Monitor

Metrics for Azure resource: (CPU Usage, Disk Metrics, Network stats)
So if you want to look at underlying metrics, such as the CPU usage, the disk metrics, the network stats, you can go ahead and use as your monitor and view the metrics in a graph format.

Alerts based on these metrics

--
Activity logs, 
    Control Place activities, When a virtual machine is stopped, When a vm is created

--
Log Analytics Workspace
  Central Solution for all of your logs

--
Application Insights
And then you have application insights, so here, this is a performance system that is available for real life applications, so you could have your applications hosted in a jar or you could have applications being hosted in your on premise environment.
You can go at and integrate application insights to see life metrics, performance metrics, although a lot of information about application bent, it is life.
So this helps to diagnose any issues in your application.

--
Storage Account
Now, another storage location that is available when it comes to your logs is and as your storage account, so you can also go out and direct locks on various resources onto and as your storage account.
---------------------
Monitor service
  metrics, select a scope: select subscription
                             select resource group, and your resource
  create pin dashboard
  go to dashbord to see app-dashboard
----
Diagnostics: Here you can send the platform logs for Azure resource to get
detailed diagnostic and auditing information

Azure resource: 
Log Analytics Workspace, 
Storage Account-Azure Data Factory
event hub  azure sql databases

---
Monitor - Activity Log
Diagnistg Settings, example send logs to satorage account
view continer in storage account
--
Monitor, alerts
create new alert rule
   filter - subscripcion-type resource
   select condition - metrics - network out total

Agreggation granularity 1minute, Frequency of evaluation Every 1minute
Entonces, cada minuto va a verificar cuáles son los datos de los últimos cinco minutos.

select an action group - create action group
---
Dynamic alert Threshold
Configure signal logic, alert logic
  Dynamic

Threshold Sensitivity [High, Medium, Low]

--
Azure Monitor Alerts - Azure Function
create function app
  add http trigger
        code+test 

	using namespace System.Net
 	param($Request, $TriggerMetadata)
 	$Request | ConvertTo-Json | Write-Outpu

create alert rule
 create action group
   action type - azure function
---
Azure Monitor Alerts - PowerShell
create Automation
go to Automation Account
Shared resources- modules - browse gallery, Az.Account(import)
	   				  Az.Resources(import)
Process Automation - create Runbooks

param ( 
    [object]$WebhookData
)
 
if ($WebhookData -ne $null) {  
 
    $WebhookBody = (ConvertFrom-Json -InputObject $WebhookData.RequestBody)
    $Context = [object]$Body.context
    $AlertContext = [object] ($WebhookBody.data).context
    $SubId = $AlertContext.subscriptionId
    $ResourceGroupName = $AlertContext.resourceGroupName
    $ResourceType = $AlertContext.resourceType
    $ResourceName = $AlertContext.resourceName 
  
    $ConnectionName = "AzureRunAsConnection"
    $Connection = Get-AutomationConnection -Name $ConnectionName
 
    Add-AzAccount -ServicePrincipal -Tenant $Connection.TenantID -ApplicationId $Connection.ApplicationID -CertificateThumbprint $Connection.CertificateThumbprint | Write-Verbose
 
 Set-AzContext -SubscriptionId $SubId -ErrorAction Stop | Write-Verbose
 
 Stop-AzVM -Name $ResourceName -ResourceGroupName $ResourceGroupName -Force
     
}

create alert rule
 create action group
   action type - automation runbook: (runbook source: user)

-------------
Monitoring Az vm
*Log Analytics Agent (Microsoft Monitoring agent)
this can be used to callect monitoring data from the guest operating system and
workloads that run on Azure vmm ither claud providers and on-premise as well
All data is collected in a Log Analytics workspace
 *Dependency Agent: Is used to callect the data that is discovered about the processes running on the vm
                     pre install Log Analytics agent
 *Telgraf agent: Is used to collect performance data form Linux computers and send it to Azure Monitor metrics
---

vm - Diagnostic settings (enable guest-level monitoring)
--
Azure Log Analytics - Resources
Create log analytics workspace

select vm - advanced settings - data - windows even logs - system

go again to Log analytics workspace - vm

log - event

// See the events generated in the last 12h , order by the TimeGenerated attribute and then see the count of events
Event | where TimeGenerated > ago(12h)
| order by TimeGenerated desc
| summarize count() by Computer

// makelist is used to pivot data by the order of values in a particular column.
Event
| where TimeGenerated > ago(12h)
| order by TimeGenerated desc
| summarize makelist(EventID) by Computer

// makeset can be used to create a list on distinct values

Event
| where TimeGenerated > ago(12h)
| order by TimeGenerated desc
| summarize makeset(EventID) by Computer

vm : monitoring - insights (selec log analytics workspace)

--
**IT Service Mangement Connector
--
Application Insights
Application Performance Mangement service for web developers

how user use the application
  Funnels: you can create a funnel from on stage to another stage of your application
          you can then see how sers are progressing through the stages of the funnel
  User Flows: this help visualize how users navigate between pages in your site

vs -> add- Application Insights Telemetry

app service - create web app
       enable application insights
       create new application insights

----
application insights - smart alerts
   - smart detection -settings

continuous export
---
application insights - availability tests
--
application insights - alerts - azure logic app
  http request is received
--
 Azure Container Instances - liveness probe - Resources
az container create --resource-group newgrp1 --name test -f app.yml
payload
{
        "schemaId": "Microsoft.Insights/activityLogs",
        "data": {
            "status": "Activated",
            "context": {
            "activityLog": {
                "authorization": {
                "action": "microsoft.insights/activityLogAlerts/write",
                "scope": "/subscriptions/…"
                },
                "channels": "Operation",
                "claims": "…",
                "caller": "logicappdemo@contoso.com",
                "correlationId": "91ad2bac-1afa-4932-a2ce-2f8efd6765a3",
                "description": "",
                "eventSource": "Administrative",
                "eventTimestamp": "2018-04-03T22:33:11.762469+00:00",
                "eventDataId": "ec74c4a2-d7ae-48c3-a4d0-2684a1611ca0",
                "level": "Informational",
                "operationName": "microsoft.insights/activityLogAlerts/write",
                "operationId": "61f59fc8-1442-4c74-9f5f-937392a9723c",
                "resourceId": "/subscriptions/…",
                "resourceGroupName": "LOGICAPP-DEMO",
                "resourceProviderName": "microsoft.insights",
                "status": "Succeeded",
                "subStatus": "",
                "subscriptionId": "…",
                "submissionTimestamp": "2018-04-03T22:33:36.1068742+00:00",
                "resourceType": "microsoft.insights/activityLogAlerts"
            }
            },
            "properties": {}
        }
    }

----


{
        "schemaId": "Microsoft.Insights/activityLogs",
        "data": {
            "status": "Activated",
            "context": {
            "activityLog": {
                "authorization": {
                "action": "microsoft.insights/activityLogAlerts/write",
                "scope": "/subscriptions/…"
                },
                "channels": "Operation",
                "claims": "…",
                "caller": "logicappdemo@contoso.com",
                "correlationId": "91ad2bac-1afa-4932-a2ce-2f8efd6765a3",
                "description": "",
                "eventSource": "Administrative",
                "eventTimestamp": "2018-04-03T22:33:11.762469+00:00",
                "eventDataId": "ec74c4a2-d7ae-48c3-a4d0-2684a1611ca0",
                "level": "Informational",
                "operationName": "microsoft.insights/activityLogAlerts/write",
                "operationId": "61f59fc8-1442-4c74-9f5f-937392a9723c",
                "resourceId": "/subscriptions/…",
                "resourceGroupName": "LOGICAPP-DEMO",
                "resourceProviderName": "microsoft.insights",
                "status": "Succeeded",
                "subStatus": "",
                "subscriptionId": "…",
                "submissionTimestamp": "2018-04-03T22:33:36.1068742+00:00",
                "resourceType": "microsoft.insights/activityLogAlerts"
            }
            },
            "properties": {}
        }
    }

------
prometheus 
Prometheus Exporter - Windows Server
vm server manager -windows server 2019
vm - networking - add inbound security rule - port 9182
download prometheus https://github.com/prometheus-community/windows_exporter/releases
rule firewall in vm port 9182
ip:9182/metrics

---

Prometheus Exporter - Linux Server
install
// First download the exporter
wget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz
// Then unzip the contents
tar xvfz node_exporter-1.0.1.linux-amd64.tar.gz
// Go to the desired directory
cd node_exporter-1.0.1.linux-amd64
// Then run the node exporter
./node_exporter

vm - networking - add inbound security rule - port 9100
ip:9100/metrics

---
Prometheus Server
other vm -  windows server 2019
install

// First make a new directory
mkdir prometheus
// Next go ahead and download the Prometheus server component
Invoke-WebRequest "https://github.com/prometheus/prometheus/releases/download/v2.22.0/prometheus-2.22.0.windows-amd64.tar.gz" -OutFile C:\prometheus\prometheus-2.22.0.windows-amd64.tar.gz
// Unzip the contents
tar xvfz prometheus-2.22.0.windows-amd64.tar.gz
// Go onto the directory
cd .\prometheus-2.22.0.windows-amd64\
// Then execute the server component
.\prometheus.exe

vm - networking - add inbound security rule - port 9090
windows defender firewall - inbound rule add - tcp port 9090
ip:9090/metrics
ip:9090/graph

--
open prometheus.yml
   static_configs:
      - targets: ['localhost:9090', '168.63.47.39:9182', '40.113.72.78.9100']

start prometheus server
.\prometheus.exe

status - configuration

----
App Center
Login:
https://appcenter.ms/
Add new app - Android - Java/Kotlin

Install
https://developer.android.com/studio

Download
https://github.com/microsoft/appcenter-sampleapp-android/tree/master

install Android sdk 11.0, 10.0

paste app secret - MainActivity

--
go to app center
build - repo github
      branch-configure build
--
signing builds
Generate Signed Bundle or APK

go to app center 
  - build configuration 
  - sign builds - on
      keystore - upload:android.jks
  - test on a real device on

distribute
  -groups

--
ios applications
1.Register the devices in the apple developer account
2. Add the devices to the provisioning profile
3. Download the provisioning profile
4. Build the application with the provisioning profile


https://docs.microsoft.com/en-us/appcenter/quickstarts/android/getting-started

===================
Test Plans
Manual Test
create test plan
 add new test case
    Steps - Action

Execute
  check good
  check bad - comment
  Create bug

Test plan - Assign testers to run all tests
send email

Chart - New test result chart
   Outcome

---
Test and Feedback extension

server url - azure devops

 start sesion
   note
   sesion timeline
    create bug

 stop sesion

go to Runs
 recent exporation sesion
   pivot: sesion
    select bug
--
*packages
--
Artifacts

Create feed
   connect to feed
--
https://www.nuget.org/
https://www.nuget.org/packages/Microsoft.Azure.DocumentDB.Core/

vs - manage nuget package
      cosmos db - install

new project (class library .net core)
 create class - console.write

properties  - package
build solution

pack
-
login un nuget.org 
  create
      new key

publish package in local system to nuget.org
use donet

cmd - command
---
new project in vs - Console App NET Core
nuget package manager - select package
update library

Artifacts - connect to feed - NugetGet
use personal access token


--
limit view of package